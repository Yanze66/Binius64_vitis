#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
/* ---------- constants (same as Rust) ---------- */

static const uint64_t RC[24] = {
    0x0000000000000001ULL,
    0x0000000000008082ULL,
    0x800000000000808aULL,
    0x8000000080008000ULL,
    0x000000000000808bULL,
    0x0000000080000001ULL,
    0x8000000080008081ULL,
    0x8000000000008009ULL,
    0x000000000000008aULL,
    0x0000000000000088ULL,
    0x0000000080008009ULL,
    0x000000008000000aULL,
    0x000000008000808bULL,
    0x800000000000008bULL,
    0x8000000000008089ULL,
    0x8000000000008003ULL,
    0x8000000000008002ULL,
    0x8000000000000080ULL,
    0x000000000000800aULL,
    0x800000008000000aULL,
    0x8000000080008081ULL,
    0x8000000000008080ULL,
    0x0000000080000001ULL,
    0x8000000080008008ULL,
};

static const int R[25] = {
     0,  1, 62, 28, 27,
    36, 44,  6, 55, 20,
     3, 10, 43, 25, 39,
    41, 45, 15, 21,  8,
    18,  2, 61, 56, 14
};

static inline int idx(int x, int y) {
    return x + 5 * y;
}

static inline uint64_t rotl(uint64_t x, int n) {
    return (x << n) | (x >> (64 - n));
}

static void dump_a0(const char* tag, uint64_t A[25]) {
    printf("%s A[0]=0x%016llx\n", tag, (unsigned long long)A[0]);
}




/* ---------- keccak steps ---------- */

static void theta(uint64_t A[25]) {
    uint64_t C[5], D[5];

    for (int x = 0; x < 5; x++) {
        C[x] = A[idx(x,0)] ^ A[idx(x,1)] ^ A[idx(x,2)]
             ^ A[idx(x,3)] ^ A[idx(x,4)];
    }

    for (int x = 0; x < 5; x++) {
        D[x] = C[(x+4)%5] ^ rotl(C[(x+1)%5], 1);
    }

	/* ===== Rust force_commit 对应点 ===== */
    printf("=== ROUND %d : THETA force_commit D[x] ===\n");
    for (int x = 0; x < 5; x++) {
        printf("D[%d] = 0x%016llx\n",
               x, (unsigned long long)D[x]);
    }

    for (int y = 0; y < 5; y++) {
        for (int x = 0; x < 5; x++) {
            A[idx(x,y)] ^= D[x];
        }
    }
}

static void rho_pi(uint64_t A[25]) {
    uint64_t T[25];
    memcpy(T, A, sizeof(T));

    for (int y = 0; y < 5; y++) {
        for (int x = 0; x < 5; x++) {
            int i = idx(x,y);
            int j = idx(y, (2*x + 3*y) % 5);
            if (R[i] == 0)
                T[j] = A[i];
            else
                T[j] = rotl(A[i], R[i]);
        }
    }

    memcpy(A, T, sizeof(T));
}

static void chi(uint64_t A[25]) {
    uint64_t T[5];
    for (int y = 0; y < 5; y++) {
        for (int x = 0; x < 5; x++)
            T[x] = A[idx(x,y)];
        for (int x = 0; x < 5; x++)
            A[idx(x,y)] ^= (~T[(x+1)%5]) & T[(x+2)%5];
    }
}

static void iota(uint64_t A[25], int round) {
    A[0] ^= RC[round];
}

static void keccak_round(uint64_t A[25], int round) {
    //dump_a0("before theta:", A);
    theta(A);
    //dump_a0("before rho:", A);
    rho_pi(A);
    //dump_a0("before chi:", A);
    chi(A);
    //dump_a0("before theta:", A);
    /* dump state */
    printf("=== STATE AFTER chi ===\n");
    for (int i = 0; i < 25; i++) {
        printf("A[%02d] = 0x%016llx\n",
               i, (unsigned long long)A[i]);
    }
    iota(A, round);
    //dump_a0("final A[0]:", A);
}

size_t pack_message_le(
    const uint8_t *msg,
    size_t len_bytes,
    uint64_t *out_words
) {
    size_t n_words = (len_bytes + 7) / 8;
    memset(out_words, 0, n_words * sizeof(uint64_t));

    for (size_t i = 0; i < len_bytes; i++) {
        size_t w = i / 8;
        size_t b = i % 8;
        out_words[w] |= ((uint64_t)msg[i]) << (8 * b);
    }
    return n_words;
}

/* ---------- test: EXACTLY like Rust ---------- */

int main(void) {
    uint64_t state[25];
    memset(state, 0, sizeof(state));

    /* ================= input (pick a test case you like and comment others) ================= */

    /* ===== choose message ===== */

    // --- 1 byte ---
    //uint8_t message[] = {0x61};
    //size_t len_bytes = 1;

    // --- 8 bytes ---
    //uint8_t message[] = {0xb2,0x60,0xb8,0xa1,0x03,0x43,0xbf,0x5a};
    //size_t len_bytes = 8;

    // --- 135 bytes  ---
    //uint8_t message[135] = {
    //    205,56,46,120,38,70,176,74, 76,161,62,248,186,171,0,97,
    //    14,97,19,181,18,218,255,110, 190,82,13,172,78,15,252,212,
    //    167,160,145,109,245,59,123,1, 104,252,210,46,223,161,102,93,
    //    148,109,214,57,223,206,145,171, 245,78,42,68,87,119,185,75,
    //    101,248,209,146,155,53,143,129, 173,242,54,174,209,171,27,215,
    //    198,250,92,195,67,161,79,113, 156,60,94,138,44,79,95,120,
    //    79,40,68,247,42,43,19,68, 34,230,149,237,238,160,33,80,
    //    23,97,248,116,231,55,174,141, 240,103,50,221,30,28,239,242,
    //    231,101,207,149,236,37,35
    //};
    //size_t len_bytes = 135;

    // --- 136 bytes  (boundary trap) ---
    //uint8_t message[136] = {
    //    237, 183, 131, 51, 22, 137, 151, 230, 14, 77, 66, 101, 196, 79, 120, 179, 230, 108, 221, 58, 129, 84, 128, 230, 171, 112, 99, 178, 130, 18, 102, 80, 235, 86, 99, 229, 216, 11, 182, 47, 116, 111, 177, 26, 149, 54, 120, 231, 108, 164, 84, 231, 214, 28, 168, 248, 163, 224, 117, 186, 255, 19, 119, 160, 223, 206, 109, 168, 117, 142, 55, 223, 189, 197, 42, 79, 245, 234, 211, 97, 28, 30, 72, 24, 11, 233, 229, 71, 145, 203, 159, 71, 94, 88, 76, 24, 49, 40, 95, 53, 119, 140, 229, 15, 191, 174, 103, 182, 203, 153, 67, 44, 254, 102, 207, 65, 222, 141, 191, 155, 93, 60, 109, 248, 250, 16, 232, 165, 121, 107, 212, 238, 244, 252, 217, 34
    //};
    //size_t len_bytes = 136;

    // --- 136 bytes  ---
    //uint8_t message[137] = {
    //    122, 99, 72, 164, 10, 28, 190, 82, 85, 197, 239, 40, 45, 110, 220, 112, 201, 169, 162, 52, 86, 187, 88, 253, 191, 225, 184, 211, 187, 251, 255, 54, 76, 119, 57, 181, 110, 13, 73, 218, 161, 15, 62, 189, 133, 27, 130, 196, 75, 17, 95, 162, 197, 226, 191, 37, 62, 130, 60, 153, 147, 34, 31, 26, 133, 251, 219, 210, 59, 152, 92, 107, 50, 251, 247, 106, 100, 87, 239, 183, 188, 242, 75, 77, 215, 34, 70, 244, 251, 161, 139, 250, 35, 172, 134, 88, 163, 150, 81, 40, 211, 64, 73, 66, 212, 17, 200, 160, 246, 183, 224, 131, 128, 124, 75, 101, 216, 43, 118, 254, 48, 209, 83, 231, 48, 193, 122, 170, 48, 95, 119, 245, 105, 16, 193, 117, 2
    //};
    //size_t len_bytes = 137;
    
    // --- 272 bytes  ---
    //uint8_t message[272] = {
    //    45, 194, 136, 189, 20, 250, 156, 137, 226, 114, 118, 197, 90, 192, 80, 78, 215, 224, 171, 219, 227, 146, 102, 144, 122, 179, 96, 139, 125, 240, 71, 73, 47, 254, 146, 84, 241, 77, 181, 85, 115, 136, 108, 3, 207, 146, 242, 137, 32, 53, 131, 127, 94, 233, 229, 142, 123, 61, 247, 27, 113, 19, 126, 80, 148, 69, 59, 95, 4, 165, 210, 48, 21, 14, 246, 23, 173, 84, 154, 90, 28, 7, 76, 244, 174, 2, 194, 241, 162, 175, 34, 180, 145, 25, 131, 135, 25, 178, 250, 173, 152, 182, 254, 171, 11, 131, 53, 147, 240, 151, 17, 126, 86, 6, 142, 121, 132, 99, 149, 186, 101, 214, 228, 70, 190, 3, 198, 203, 97, 222, 63, 45, 91, 119, 174, 94, 104, 210, 79, 46, 36, 183, 5, 183, 128, 81, 136, 184, 80, 123, 157, 92, 208, 116, 250, 186, 248, 201, 205, 87, 14, 175, 8, 46, 23, 107, 218, 239, 133, 110, 7, 9, 193, 173, 41, 39, 183, 228, 42, 154, 153, 184, 205, 97, 195, 241, 141, 205, 58, 243, 228, 209, 68, 139, 216, 1, 77, 242, 172, 110, 2, 162, 142, 133, 246, 64, 248, 180, 62, 3, 50, 163, 179, 164, 96, 31, 16, 34, 4, 91, 91, 237, 5, 71, 91, 196, 201, 11, 167, 12, 135, 6, 134, 15, 145, 57, 229, 62, 54, 169, 155, 115, 111, 1, 39, 20, 183, 156, 127, 131, 64, 37, 39, 254, 45, 255, 26, 70, 56, 182, 153, 235, 254, 57, 220, 39, 101, 19, 57, 83, 44, 17
    //};
    //size_t len_bytes = 272;
    
    // --- 500 bytes  ---
    //uint8_t message[500] = {
    //    147, 227, 24, 3, 117, 240, 57, 232, 98, 139, 116, 128, 158, 134, 44, 53, 148, 136, 194, 237, 39, 184, 11, 211, 30, 115, 111, 167, 94, 95, 238, 180, 150, 155, 55, 43, 108, 95, 81, 242, 100, 192, 78, 169, 182, 179, 159, 39, 228, 22, 191, 206, 192, 208, 207, 36, 79, 255, 229, 213, 212, 72, 113, 237, 31, 251, 0, 59, 36, 135, 114, 254, 30, 52, 78, 14, 192, 134, 36, 16, 254, 15, 14, 161, 66, 202, 241, 97, 80, 110, 147, 81, 12, 202, 50, 17, 165, 7, 236, 36, 251, 141, 111, 182, 28, 253, 86, 62, 115, 77, 91, 161, 39, 39, 57, 160, 45, 218, 35, 118, 231, 109, 151, 28, 98, 12, 165, 38, 97, 88, 35, 26, 60, 7, 15, 66, 30, 128, 44, 169, 154, 8, 217, 104, 8, 235, 167, 128, 64, 123, 77, 228, 78, 21, 194, 8, 104, 240, 97, 115, 81, 29, 14, 56, 173, 158, 218, 254, 102, 71, 29, 4, 58, 104, 57, 177, 28, 170, 6, 160, 12, 193, 98, 103, 144, 54, 123, 50, 226, 140, 119, 69, 60, 219, 228, 193, 153, 150, 251, 87, 210, 146, 168, 163, 117, 168, 232, 114, 115, 124, 81, 239, 176, 83, 126, 198, 79, 127, 83, 57, 145, 137, 204, 97, 17, 227, 30, 46, 9, 189, 160, 214, 74, 72, 201, 66, 196, 255, 252, 58, 209, 49, 4, 11, 174, 94, 113, 131, 180, 184, 11, 108, 2, 117, 246, 167, 40, 251, 160, 15, 249, 221, 194, 131, 162, 195, 246, 150, 208, 32, 20, 108, 229, 162, 231, 114, 218, 172, 110, 101, 22, 191, 93, 133, 91, 53, 186, 168, 146, 30, 22, 93, 80, 204, 137, 224, 101, 249, 163, 135, 45, 210, 62, 55, 236, 137, 223, 162, 240, 25, 255, 41, 160, 16, 21, 196, 229, 82, 177, 156, 252, 234, 125, 160, 191, 128, 20, 22, 173, 149, 230, 181, 225, 133, 248, 221, 144, 146, 182, 137, 29, 204, 100, 74, 58, 23, 87, 29, 103, 205, 84, 23, 222, 50, 14, 84, 70, 217, 192, 89, 188, 105, 98, 173, 4, 155, 129, 138, 117, 121, 77, 181, 112, 43, 254, 106, 111, 16, 197, 7, 199, 228, 98, 249, 84, 194, 121, 172, 196, 227, 238, 215, 87, 110, 22, 213, 130, 77, 2, 89, 104, 229, 159, 233, 221, 58, 42, 146, 18, 211, 41, 154, 81, 159, 28, 191, 100, 237, 155, 40, 219, 216, 94, 191, 191, 44, 12, 94, 70, 94, 237, 194, 152, 225, 90, 10, 249, 7, 79, 252, 152, 137, 95, 228, 72, 184, 89, 209, 126, 83, 209, 119, 137, 40, 122, 129, 187, 153, 105, 34, 233, 196, 49, 86, 174, 95, 174, 202, 101, 226, 0, 129, 106, 201, 224, 112, 219, 7, 131, 222, 237, 70, 253, 213, 174, 102, 187, 147, 140, 147, 196, 147, 190, 130, 79, 246, 249, 217, 142, 231
    //};
    //size_t len_bytes = 500;
    
    // --- 1500 bytes (Arbitrary length)  ---
    uint8_t message[1500] = {
        126, 180, 71, 115, 207, 213, 243, 53, 82, 30, 47, 160, 113, 84, 11, 186, 71, 49, 236, 182, 218, 198, 13, 89, 92, 121, 214, 157, 212, 225, 253, 26, 62, 147, 10, 11, 7, 141, 206, 144, 181, 60, 187, 152, 92, 122, 108, 169, 127, 216, 251, 247, 240, 220, 98, 187, 109, 28, 172, 195, 22, 138, 122, 115, 255, 105, 255, 15, 14, 219, 209, 34, 227, 28, 131, 117, 194, 187, 158, 223, 153, 11, 194, 237, 212, 246, 218, 127, 32, 194, 171, 116, 37, 114, 243, 203, 142, 43, 98, 110, 103, 130, 26, 169, 137, 155, 36, 40, 6, 252, 151, 23, 169, 166, 163, 110, 71, 4, 34, 52, 212, 70, 117, 178, 85, 169, 225, 223, 50, 3, 62, 251, 129, 43, 158, 6, 236, 54, 76, 166, 167, 197, 121, 201, 170, 135, 182, 214, 49, 128, 11, 253, 146, 217, 119, 26, 235, 92, 59, 124, 120, 207, 155, 7, 192, 101, 245, 171, 212, 120, 190, 18, 103, 107, 150, 66, 87, 83, 218, 254, 99, 246, 61, 64, 198, 223, 5, 77, 45, 0, 199, 158, 26, 235, 224, 251, 159, 115, 50, 113, 203, 120, 231, 184, 153, 137, 115, 202, 120, 118, 140, 164, 237, 166, 105, 38, 2, 11, 164, 146, 183, 68, 174, 253, 103, 122, 160, 17, 9, 8, 73, 247, 149, 70, 34, 95, 166, 206, 48, 142, 249, 254, 117, 225, 250, 16, 84, 68, 197, 117, 232, 237, 179, 90, 35, 71, 216, 81, 175, 181, 208, 172, 134, 187, 84, 216, 104, 196, 128, 184, 253, 86, 17, 201, 227, 174, 123, 192, 241, 141, 177, 41, 135, 60, 1, 228, 126, 247, 176, 7, 65, 160, 71, 74, 138, 198, 215, 113, 132, 131, 72, 99, 115, 175, 60, 124, 87, 90, 251, 117, 24, 25, 70, 254, 18, 9, 86, 13, 27, 152, 214, 24, 27, 248, 255, 211, 51, 96, 144, 188, 43, 187, 48, 143, 178, 67, 37, 18, 42, 222, 43, 122, 34, 24, 175, 219, 182, 174, 152, 125, 194, 208, 42, 61, 110, 105, 107, 126, 171, 182, 152, 197, 98, 241, 2, 62, 219, 197, 29, 8, 144, 94, 34, 197, 48, 153, 205, 109, 194, 175, 91, 126, 129, 166, 131, 147, 148, 81, 65, 39, 196, 33, 215, 243, 164, 167, 244, 217, 233, 224, 66, 84, 144, 134, 69, 242, 3, 235, 73, 97, 173, 51, 255, 192, 194, 102, 179, 209, 135, 23, 151, 24, 198, 124, 246, 147, 102, 85, 144, 56, 2, 83, 62, 16, 249, 244, 110, 17, 29, 169, 78, 240, 160, 208, 181, 35, 237, 166, 171, 23, 137, 216, 35, 46, 194, 53, 132, 131, 30, 3, 128, 196, 16, 115, 215, 161, 73, 222, 160, 76, 158, 233, 75, 254, 19, 220, 57, 24, 78, 42, 92, 141, 210, 57, 28, 255, 57, 108, 112, 177, 166, 116, 81, 84, 210, 4, 30, 218, 120, 224, 234, 161, 90, 155, 118, 189, 165, 11, 111, 53, 60, 108, 4, 119, 227, 89, 27, 153, 109, 180, 85, 57, 105, 238, 132, 44, 222, 81, 158, 188, 93, 245, 213, 101, 157, 124, 142, 161, 194, 242, 78, 192, 44, 248, 82, 28, 243, 26, 48, 22, 92, 227, 169, 181, 200, 243, 191, 232, 139, 54, 214, 237, 13, 66, 12, 12, 201, 134, 236, 83, 191, 43, 166, 193, 71, 35, 187, 9, 180, 209, 205, 103, 61, 129, 221, 255, 62, 159, 56, 72, 166, 238, 55, 101, 32, 162, 35, 196, 212, 211, 57, 102, 240, 122, 103, 185, 40, 182, 161, 138, 188, 225, 212, 33, 126, 45, 21, 250, 75, 62, 175, 70, 141, 157, 3, 95, 192, 217, 98, 198, 126, 157, 22, 222, 142, 230, 179, 199, 149, 21, 49, 37, 254, 35, 45, 202, 38, 14, 196, 205, 227, 3, 146, 149, 89, 250, 153, 174, 231, 154, 76, 83, 68, 201, 62, 43, 17, 80, 42, 91, 169, 40, 227, 108, 249, 103, 197, 84, 203, 122, 246, 95, 59, 185, 182, 171, 157, 121, 172, 184, 124, 243, 145, 120, 133, 9, 94, 161, 4, 162, 134, 178, 151, 11, 149, 204, 184, 145, 192, 11, 115, 130, 206, 169, 156, 225, 198, 46, 113, 38, 97, 154, 110, 135, 75, 25, 172, 125, 206, 199, 48, 49, 15, 183, 60, 107, 147, 135, 54, 253, 32, 252, 139, 7, 240, 99, 6, 218, 42, 254, 114, 167, 38, 93, 159, 77, 122, 194, 250, 56, 184, 166, 179, 165, 105, 225, 137, 10, 37, 156, 25, 102, 94, 139, 142, 83, 239, 107, 38, 26, 61, 91, 191, 150, 112, 157, 91, 30, 208, 0, 157, 129, 79, 168, 17, 205, 144, 150, 157, 46, 230, 248, 221, 113, 227, 211, 179, 26, 162, 184, 171, 184, 4, 212, 134, 102, 152, 189, 134, 72, 162, 147, 90, 234, 166, 238, 194, 252, 26, 214, 92, 128, 147, 146, 176, 250, 121, 242, 134, 152, 77, 193, 201, 205, 129, 78, 119, 124, 130, 72, 106, 156, 151, 40, 154, 73, 42, 222, 129, 240, 29, 154, 219, 21, 44, 197, 211, 147, 102, 215, 175, 168, 34, 201, 81, 124, 188, 145, 102, 133, 236, 172, 51, 34, 126, 160, 190, 182, 251, 22, 206, 245, 76, 253, 121, 16, 52, 83, 34, 135, 189, 69, 152, 213, 157, 137, 239, 158, 45, 201, 214, 222, 107, 135, 195, 73, 247, 27, 179, 148, 83, 125, 141, 5, 210, 142, 247, 150, 190, 146, 136, 205, 2, 224, 28, 225, 186, 25, 145, 19, 216, 172, 181, 115, 234, 135, 194, 72, 232, 87, 173, 196, 82, 127, 230, 80, 177, 103, 110, 128, 85, 76, 207, 59, 22, 69, 61, 229, 11, 15, 2, 217, 46, 139, 193, 180, 145, 18, 79, 173, 188, 90, 54, 145, 81, 210, 70, 50, 156, 187, 75, 144, 238, 10, 205, 255, 87, 131, 101, 89, 51, 88, 33, 202, 242, 224, 30, 123, 181, 234, 210, 2, 89, 66, 16, 167, 135, 26, 42, 141, 239, 219, 139, 131, 18, 176, 189, 244, 141, 82, 188, 90, 255, 137, 199, 111, 120, 187, 216, 28, 134, 8, 196, 182, 157, 220, 122, 69, 57, 217, 121, 140, 136, 113, 48, 235, 156, 100, 205, 11, 96, 139, 11, 229, 32, 36, 104, 182, 45, 204, 64, 99, 191, 12, 91, 136, 78, 62, 14, 118, 98, 229, 191, 146, 211, 44, 37, 80, 206, 85, 238, 115, 99, 171, 10, 19, 144, 247, 74, 162, 175, 97, 5, 219, 225, 176, 26, 85, 216, 44, 220, 129, 29, 242, 162, 199, 58, 249, 185, 233, 111, 56, 182, 66, 176, 165, 61, 211, 135, 97, 126, 58, 246, 45, 57, 100, 242, 246, 31, 176, 184, 187, 94, 0, 161, 22, 183, 234, 181, 164, 135, 192, 127, 0, 91, 168, 109, 14, 254, 117, 139, 182, 186, 110, 211, 182, 20, 191, 178, 136, 207, 159, 169, 72, 109, 253, 229, 137, 196, 43, 116, 19, 61, 59, 238, 244, 144, 240, 207, 12, 215, 230, 227, 218, 97, 7, 31, 158, 209, 138, 85, 84, 123, 77, 61, 75, 230, 8, 40, 143, 215, 48, 59, 172, 86, 178, 97, 229, 149, 58, 82, 5, 213, 235, 18, 227, 191, 164, 190, 40, 1, 202, 4, 180, 112, 175, 119, 105, 84, 155, 192, 156, 180, 227, 81, 243, 62, 186, 139, 211, 135, 110, 209, 46, 61, 9, 137, 130, 128, 243, 250, 42, 10, 126, 209, 120, 162, 149, 158, 168, 143, 196, 246, 106, 34, 87, 44, 56, 163, 2, 115, 130, 12, 150, 199, 197, 48, 152, 182, 205, 248, 123, 169, 80, 153, 74, 117, 205, 157, 3, 78, 41, 5, 70, 247, 178, 138, 42, 23, 208, 178, 0, 186, 194, 129, 140, 150, 233, 194, 59, 91, 133, 237, 106, 143, 227, 155, 112, 145, 226, 241, 248, 207, 188, 238, 186, 127, 189, 85, 38, 113, 202, 96, 59, 150, 123, 239, 160, 187, 53, 66, 92, 185, 166, 244, 146, 113, 77, 235, 122, 233, 93, 45, 199, 186, 129, 118, 94, 180, 191, 181, 251, 36, 253, 49, 69, 15, 124, 143, 184, 152, 255, 194, 205, 24, 11, 23, 187, 183, 86, 101, 86, 197, 231, 87, 197, 135, 177, 194, 235, 252, 226, 76, 85, 6, 130, 93, 236, 190, 202, 144, 98, 225, 172, 81, 193, 87, 80, 116, 21, 82, 32, 37, 101, 174, 36, 57, 239, 102, 116, 3, 180, 238, 102, 40, 81, 113, 96, 50, 53, 138, 39, 9, 78, 148, 229, 102, 193, 151, 144, 213, 113, 226, 168, 31, 246, 204, 142, 217, 133, 145, 92, 114, 230, 172, 93, 226, 4, 147, 162, 17, 192, 10, 151, 102, 109, 92, 65, 166, 154, 153, 44, 39, 2, 254, 6, 248, 205, 41, 95, 88, 36, 243, 167, 22, 1, 206, 113, 214, 191
    };
    size_t len_bytes = 1500;
    /* ================= debug message ================= */
    printf("=== INPUT MESSAGE (%zu bytes) ===\n", len_bytes);

    /* print bytes */
    printf("Bytes: [");
    for (size_t i = 0; i < len_bytes; i++) {
        printf("%u", message[i]);
        if (i + 1 < len_bytes) printf(", ");
    }
    printf("]\n");

    /* print hex */
    printf("Hex (word-reversed, zero-padded to 8 bytes per word): ");
    size_t i = 0;
    while (i < len_bytes) {
        // initialize 
        uint8_t word[8] = {0};
        
        // chunck size
        size_t chunk = (len_bytes - i >= 8) ? 8 : (len_bytes - i);
        
        // inverse print
        for (size_t j = 0; j < chunk; j++) {
            word[7 - j] = message[i + j]; // 
        }
        
        for (size_t j = 0; j < 8; j++) {
            printf("%02x", word[j]);
        }
        
        printf("\n"); // 
        i += chunk;
    }
    printf("\n\n");
    /* ================= padding ================= */
    const size_t RATE_WORDS = 17;

    /* number of blocks */
    size_t n_blocks = (len_bytes + 1 + 136 - 1) / 136;
    size_t n_padded_words = n_blocks * RATE_WORDS;

    /* padded message */
    uint64_t *padded = calloc(n_padded_words, sizeof(uint64_t));


    size_t full_words = len_bytes / 8;
    size_t rem_bytes  = len_bytes % 8;

    /* full words */
    for (size_t i = 0; i < full_words; i++) {
        uint64_t w = 0;
        for (int b = 0; b < 8; b++)
            w |= ((uint64_t)message[8*i + b]) << (8*b);
        padded[i] = w;
    }

    /* boundary word, add 0x01 at the end of the msg */
    if (rem_bytes == 0) {
        padded[full_words] = 0x01ULL;
    } else {
        uint64_t last = 0;
        for (size_t b = 0; b < rem_bytes; b++)
            last |= ((uint64_t)message[8*full_words + b]) << (8*b);

        uint64_t padding_bit = 1ULL << (rem_bytes * 8);
        padded[full_words] = last ^ padding_bit;
    }

    /* ---- final 0x80 << 56 ---- */
    padded[n_blocks * RATE_WORDS - 1] ^= (0x80ULL << 56);

    /* ================= debug padding ================= */
    //printf("=== PADDED WORDS ===\n");
    //for (int i = 0; i < RATE_WORDS; i++) {
    //    printf("padded[%02d] = 0x%016llx\n",
    //           i, (unsigned long long)padded[i]);
    //}

    /* ================= absorb and permutation ================= */
    for (size_t b = 0; b < n_blocks; b++) {
    	/* absorb one block */
    	for (int i = 0; i < RATE_WORDS; i++) {
    	    state[i] ^= padded[b * RATE_WORDS + i];
    	}

    	/* permutation */
    	for (int r = 0; r < 24; r++) {
    	    keccak_round(state, r);
    	}
    }

    /* ================= digest ================= */
    printf("\n=== DIGEST (state[0..3]) ===\n");
    for (int i = 0; i < 4; i++) {
        printf("digest[%d] = 0x%016llx\n",
               i, (unsigned long long)state[i]);
    }

    return 0;
}

